/**
 * Capsule AIO API v1
 *
 * API Handler
 *
 * This API is designed to handle all interaction a user may have using the capsule aio website,
 * as well as some functions that the application will use when binding and/or activating the user's key.
 * Including:
 *  - Getting User Data from Db
 *  - Activating a capsule AIO key to a User
 *  - Binding a copy of Capsule AIO to the user's activated Key
 *
 */

;`use strict`

const qs = require('qs')

const {
  TryBindKey,
  TryUnbindKey,
  TryTakeKey,
  GetUser,
  GetAioConnections,
  InputFingerprint,
  GetUserCount,
  GetConnectedUserCount
} = require('db')
const { deleteConnection } = require('mgmt')
const kms = require('kms')
const authorizer = require('./lib/authorizer')
const CryptoJS = require('qq-crypto/google')

const { getToken, getNokamai, getPixel, getInitialFingerprint } = require('./lib/nokamaiHandler')
const { success, fail, invalidDataResponse, unauthorized } = require('./lib/returns')
const discordCallback = require('./lib/callback')

const { FAKAM_AES_ENCRYPTION_KEY } = process.env

exports.authorizer = authorizer
exports.discordCallback = discordCallback
exports.getNokamai = getNokamai
exports.getPixel = getPixel
exports.getInitialFingerprint = getInitialFingerprint
exports.getToken = getToken

/**
 * Returns user data to the client.
 * Requires the client to have done an oauth2 already.
 *
 * Authorizer will have supplied auth in the event.requestContext.authorizer.principalId property.
 * @param {*} event
 * @returns
 */
exports.getUser = async event => {
  console.log('event', event)

  const auth = JSON.parse(
    Buffer.from(event.requestContext.authorizer.principalId, 'base64').toString('ascii'),
  )

  // const result = await userRequest(payload.auth)
  console.log('user', auth.user)

  const payload = {
    id: auth.user.id,
    email: auth.user.email,
    username: auth.user.username,
    avatar: auth.user.avatar,
    discriminator: auth.user.discriminator,
  }

  try {
    const dbUser = await GetUser(auth.user.id)

    dbUser.keyId && (payload.key = dbUser.keyId)
    dbUser.bind && (payload.bind = true)
  } catch (err) {
    console.error('User not found', err)
  }

  return {
    ...success,
    headers: {
      ...success.headers,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(payload),
  }
}

/**
 * Binds a user's key to an instance of the installed capsule aio application.
 * Only one application may be bound at any time. A user will need to use
 * the key reset option on the dashboard to unbind it from a copy of capsule aio
 * so they can login from another location.
 *
 * User is required to supply their license key and the public key generated by
 * their client. The user's IP will also be stored and used to verify their
 * identity.
 * @param {*} event
 * @returns
 */
exports.bindKey = async event => {
  console.log('event', event)

  try {
    var { lic, key } = qs.parse(event.body)
    console.log('license key', lic)
    console.log('public key', key)
  } catch (err) {
    console.error('Error parsing submitted key.', err)

    return {
      statusCode: 400,
    }
  }

  try {
    await TryBindKey(
      lic,
      Buffer.from(key, 'base64').toString('ascii'),
      event.requestContext.identity.sourceIp,
    )

    const publicKey = await kms.getPublicKey()

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'text/plain',
      },
      body: Buffer.from(publicKey).toString('base64'),
    }
  } catch (err) {
    console.error('User not found', err)
    return { statusCode: 404 }
  }
}

exports.unbind = async event => {
  console.log('event', event)

  const auth = JSON.parse(
    Buffer.from(event.requestContext.authorizer.principalId, 'base64').toString('ascii'),
  )

  // const result = await userRequest(payload.auth)
  console.log('user', auth.user)

  let dbUser

  try {
    dbUser = await GetUser(auth.user.id)

    if (!dbUser.keyId) throw new Error('User is not bound')
    if (!dbUser.bind) throw new Error('Key is not bound')
  } catch (err) {
    console.error('User and/or key not found', err)
    return { statusCode: 404 }
  }

  try {
    /**
     * Disconnect all sessions
     */
    for (var session of await GetAioConnections(dbUser.keyId)) {
      try {
        console.log('Deleting connection:', session.id)
        await deleteConnection(session.id)
        console.log('Deleted connection:', session.id)
      } catch {
        console.log('Unable to delete connection:', session.id)
      }
    }

    /**
     * Unbind user
     */
    await TryUnbindKey(dbUser.id, dbUser.key, dbUser.keyId, event.requestContext.identity.sourceIp)

    /**
     * Check for any last sessions and disconnect them
     */
    for (var session of await GetAioConnections(dbUser.keyId)) {
      try {
        console.log('Deleting connection:', session.id)
        await deleteConnection(session.id)
        console.log('Deleted connection:', session.id)
      } catch {
        console.log('Unable to delete connection:', session.id)
      }
    }

    return {
      ...success,
      headers: {
        ...success.headers,
      },
    }
  } catch (err) {
    console.error('Unable to unbind key', err)
    return { statusCode: 500 }
  }
}

/**
 * Activates key in the database so that it can be used with the capsule aio app.
 * Requires that the key be unactivated in the database.
 * @param {*} event
 * @returns Data for the activated user to be displayed on the page.
 */
exports.activateKey = async event => {
  console.log('event', event)

  const auth = JSON.parse(
    Buffer.from(event.requestContext.authorizer.principalId, 'base64').toString('ascii'),
  )

  // const result = await userRequest(payload.auth)
  // console.log('user', auth)

  try {
    var { key: keyId } = qs.parse(event.body)
    // console.log('key', keyId)
  } catch (err) {
    console.error('Error parsing submitted key.', err)
    return invalidDataResponse
  }

  try {
    var user = await TryTakeKey(keyId, auth.user.id, event.requestContext.identity.sourceIp)
    console.log('Try take result:', user)

    const payload = {
      id: auth.user.id,
      email: auth.user.email,
      username: auth.user.username,
      avatar: auth.user.avatar,
      discriminator: auth.user.discriminator,
      ...(user.keyId && { key: user.keyId }),
    }

    return {
      ...success,
      headers: {
        ...success.headers,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload),
    }
  } catch (err) {
    console.error('Error with trytake', err)
  }

  return fail
}

/**
 * Inputs an encrypted fAkam fingerprint into the 'fAkam' type in the database
 * @param {*} event
 */
exports.inputFingerprint = async event => {
  // console.log('event', event)

  try {
    const decrypted = CryptoJS.AES.decrypt(event.body, FAKAM_AES_ENCRYPTION_KEY)
    const fAkam = JSON.parse(decrypted.toString(CryptoJS.enc.Utf8))

    const id = fAkam.id
    console.log('fAkam id', id)
    delete fAkam.id

    await InputFingerprint(id, fAkam)
  } catch (err) {
    console.error('Error Handling Input For Fingerprint:', event.body, 'Error:', err.message) // Log error into AWS Cloudwatch lambda function logs
  } finally {
    return {
      statusCode: 200, // Always return status 200, even on error to misguide users trying to replicate requests based on the success of the request
    }
  }
}

exports.getUserCount = async event => {
  console.log('event', event)

  const { user } = JSON.parse(
    Buffer.from(event.requestContext.authorizer.principalId, 'base64').toString('ascii'),
  )

  console.log('user', user)

  try {
    const dbUser = await GetUser(user.id)

    if (!dbUser.admin) return unauthorized
  } catch (err) {
    console.error('User not found', err)
    return unauthorized
  }

  try {
    const count = await GetUserCount()
    
    return {
      ...success,
      headers: {
        ...success.headers,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ count }),
    }
  } catch (err) {
    console.error('GetUserCount error', err)
    return fail
  }
}

exports.getConnectedUserCount = async event => {
  console.log('event', event)

  const { user } = JSON.parse(
    Buffer.from(event.requestContext.authorizer.principalId, 'base64').toString('ascii'),
  )

  console.log('user', user)

  try {
    const dbUser = await GetUser(user.id)

    if (!dbUser.admin) return unauthorized
  } catch (err) {
    console.error('User not found', err)
    return unauthorized
  }

  try {
    const count = await GetConnectedUserCount()
    
    return {
      ...success,
      headers: {
        ...success.headers,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ count }),
    }
  } catch (err) {
    console.error('GetConnectedUserCount error', err)
    return fail
  }
}
